<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>å·å°æ¡¥ | æ— æ­¢ - å®æ—¶æ— éšœç¢åœ°å›¾ (V21.3 ç¨³å®šä¿®å¤ç‰ˆ)</title>
    
    <!-- 1. åŸºç¡€åº“ -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- 2. Firebase -->
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore-compat.js"></script>

    <!-- 3. Leaflet åœ°å›¾ -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
    
    <!-- 4. æˆªå›¾åº“ -->
    <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>

    <style>
        body, html, #root { margin: 0; padding: 0; height: 100%; width: 100%; overflow: hidden; font-family: system-ui, -apple-system, sans-serif; }
        
        #map-container { position: absolute; top: 0; left: 0; right: 0; bottom: 0; z-index: 0; }
        .ui-layer { position: relative; z-index: 10; pointer-events: none; height: 100%; width: 100%; }
        .pointer-events-auto { pointer-events: auto; }
        
        /* æ ‡è®°æ ·å¼ */
        .custom-div-icon { background: transparent; border: none; }
        .marker-pin {
            width: 30px; height: 30px; border-radius: 50% 50% 50% 0; background: #3b82f6; position: absolute; transform: rotate(-45deg);
            left: 50%; top: 50%; margin: -15px 0 0 -15px;
            box-shadow: 0 3px 5px rgba(0,0,0,0.3);
            border: 2px solid #FFFFFF;
            display: flex; align-items: center; justify-content: center;
            transition: all 0.2s ease;
        }
        .marker-pin i { transform: rotate(45deg); font-style: normal; color: white; font-weight: bold; font-size: 14px; }
        
        /* é¢œè‰²å®šä¹‰ */
        .marker-obstacle { background: #ef4444; }
        .marker-facility { background: #22c55e; }
        .marker-experience { background: #3b82f6; }
        .marker-fixed { background: #64748b !important; border-color: #cbd5e1 !important; }

        .marker-others { opacity: 0.6; filter: grayscale(30%); transform: rotate(-45deg) scale(0.9) !important; }
        .marker-mine { z-index: 800 !important; border-color: #fff; box-shadow: 0 4px 8px rgba(0,0,0,0.4); }

        .marker-selected { transform: rotate(-45deg) scale(1.3) !important; border-color: #fbbf24 !important; z-index: 999 !important; opacity: 1 !important; filter: none !important; }
        
        .map-crosshair { cursor: crosshair !important; }
        
        .toggle-checkbox:checked { right: 0; border-color: #3b82f6; }
        .toggle-checkbox:checked + .toggle-label { background-color: #3b82f6; }
        
        @keyframes gauge { from { width: 0%; } }
        .gauge-anim { animation: gauge 1s ease-out forwards; }

        /* åŠ è½½åŠ¨ç”» */
        .scanning-bar {
            position: absolute; top: 0; left: 0; width: 100%; height: 4px; background: linear-gradient(90deg, transparent, #3b82f6, transparent);
            animation: scan 1.5s infinite; z-index: 5000; display: none;
        }
        .scanning .scanning-bar { display: block; }
        @keyframes scan { 0% { transform: translateX(-100%); } 100% { transform: translateX(100%); } }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useMemo } = React;

        // ============================================================================
        // âš ï¸ é…ç½®åŒºåŸŸ
        // ============================================================================
        const FIREBASE_CONFIG = {
            apiKey: "AIzaSyCcBlaYfmLizo1E6mV87U6ytReqSuMTX5M",
             authDomain: "scuwzq-9bcfb.firebaseapp.com",
             projectId: "scuwzq-9bcfb",
             storageBucket: "scuwzq-9bcfb.firebasestorage.app",
             messagingSenderId: "1028374721634",
             appId: "1:1028374721634:web:30714cb0acb6a951590d3b" 
        };
        // ============================================================================

        // --- AI API é…ç½® (ç”¨äºåˆ†æåŠŸèƒ½) ---
        const GEMINI_API_KEY = "";
        const AI_ENDPOINT_URL = "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent";

        let db = null;
        let auth = null;
        let isOfflineMode = true;

        if (FIREBASE_CONFIG.apiKey && FIREBASE_CONFIG.apiKey.length > 5) {
            try {
                if (!firebase.apps.length) firebase.initializeApp(FIREBASE_CONFIG);
                auth = firebase.auth();
                db = firebase.firestore();
                db.settings({ merge: true });
                isOfflineMode = false;
                console.log("ğŸ”¥ åœ¨çº¿æ¨¡å¼");
            } catch (e) { console.error(e); }
        }

        const Icons = {
            Navigation: ({size=24}) => <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polygon points="3 11 22 2 13 21 11 13 3 11"/></svg>,
            AlertTriangle: ({size=24}) => <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"/><line x1="12" y1="9" x2="12" y2="13"/><line x1="12" y1="17" x2="12.01" y2="17"/></svg>,
            CheckCircle: ({size=24}) => <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/><polyline points="22 4 12 14.01 9 11.01"/></svg>,
            Users: ({size=24}) => <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"/><circle cx="9" cy="7" r="4"/><path d="M23 21v-2a4 4 0 0 0-3-3.87"/><path d="M16 3.13a4 4 0 0 1 0 7.75"/></svg>,
            X: ({size=24}) => <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>, 
            Wifi: ({size=24}) => <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M5 12.55a11 11 0 0 1 14.08 0"/><path d="M1.42 9a16 16 0 0 1 21.16 0"/><path d="M8.53 16.11a6 6 0 0 1 6.95 0"/><line x1="12" y1="20" x2="12.01" y2="20"/></svg>,
            WifiOff: ({size=24}) => <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="1" y1="1" x2="23" y2="23"/><path d="M16.72 11.06A10.94 10.94 0 0 1 19 12.55"/><path d="M5 12.55a10.94 10.94 0 0 1 5.17-2.39"/><path d="M10.71 5.05A16 16 0 0 1 22.58 9"/><path d="M1.42 9a15.91 15.91 0 0 1 4.7-2.88"/><path d="M8.53 16.11a6 6 0 0 1 6.95 0"/><line x1="12" y1="20" x2="12.01" y2="20"/></svg>,
            Download: ({size=24}) => <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>,
            Camera: ({size=24}) => <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"/><circle cx="12" cy="13" r="4"/></svg>,
            BarChart2: ({size=24}) => <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="18" y1="20" x2="18" y2="10"/><line x1="12" y1="20" x2="12" y2="4"/><line x1="6" y1="20" x2="6" y2="14"/></svg>,
            PieChart: ({size=24}) => <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21.21 15.89A10 10 0 1 1 8 2.83"/><path d="M22 12A10 10 0 0 0 12 2v10z"/></svg>,
            Activity: ({size=24}) => <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="22 12 18 12 15 21 9 3 6 12 2 12"/></svg>,
            Star: ({size=24, fill="none"}) => <svg width={size} height={size} viewBox="0 0 24 24" fill={fill} stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"/></svg>,
            Upload: ({size=24}) => <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" y1="3" x2="12" y2="15"/></svg>,
            Image: ({size=24}) => <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"/><circle cx="8.5" cy="8.5" r="1.5"/><polyline points="21 15 16 10 5 21"/></svg>,
            Layers: ({size=24}) => <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polygon points="12 2 2 7 12 12 22 7 12 2"/><polyline points="2 17 12 22 22 17"/><polyline points="2 12 12 17 22 12"/></svg>,
            Eye: ({size=24}) => <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/><circle cx="12" cy="12" r="3"/></svg>,
            EyeOff: ({size=24}) => <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19m-6.72-1.07a3 3 0 1 1-4.24-4.24"/><line x1="1" y1="1" x2="23" y2="23"/></svg>,
            Trophy: ({size=24}) => <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M8 21h8m-4-9v9m-6.7-6.27a4 4 0 1 1 0-7.73h13.4a4 4 0 1 1 0 7.73z"/></svg>,
            User: ({size=24}) => <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"/><circle cx="12" cy="7" r="4"/></svg>,
            MapPin: ({size=24}) => <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"/><circle cx="12" cy="10" r="3"/></svg>,
            Search: ({size=24}) => <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/></svg>,
            Plus: ({size=24}) => <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></svg>,
            Save: ({size=24}) => <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/><polyline points="17 21 17 13 7 13 7 21"/><polyline points="7 3 7 8 15 8"/></svg>,
            Edit2: ({size=24}) => <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"/></svg>,
            Square: ({size=24}) => <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"/></svg>,
            PenTool: ({size=24}) => <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M12 19l7-7 3 3-7 7-3-3z"/><path d="M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z"/><path d="M2 2l7.586 7.586"/><circle cx="11" cy="11" r="2"/></svg>,
            Trash2: ({size=24}) => <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/><line x1="10" y1="11" x2="10" y2="17"/><line x1="14" y1="11" x2="14" y2="17"/></svg>,
            Target: ({size=24}) => <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="10"/><circle cx="12" cy="12" r="6"/><circle cx="12" cy="12" r="2"/></svg>,
            Table: ({size=24}) => <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M9 3H5a2 2 0 0 0-2 2v4m6-6h10a2 2 0 0 1 2 2v4M9 3v18m0 0h10a2 2 0 0 0 2-2v-4M9 21H5a2 2 0 0 1-2-2v-4"/></svg>,
            Zap: ({size=24}) => <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"/></svg>,
            Road: ({size=24}) => <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M5 21l8-17H3m14 0l-8 17h16"/></svg>,
            Building: ({size=24}) => <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect x="3" y="5" width="18" height="16" rx="2"/><line x1="6" y1="17" x2="6" y2="10"/><line x1="10" y1="17" x2="10" y2="10"/><line x1="14" y1="17" x2="14" y2="10"/><line x1="18" y1="17" x2="18" y2="10"/></svg>,
            Droplet: ({size=24}) => <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M12 2.69l5.66 5.66c1.15 1.15 1.15 3.02 0 4.17l-5.66 5.66c-1.15 1.15-3.02 1.15-4.17 0l-5.66-5.66c-1.15-1.15-1.15-3.02 0-4.17l5.66-5.66z"/></svg>,
            TreePine: ({size=24}) => <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M7.74 15.68L2 21h20l-5.74-5.32c-1.15-1.15-3.02-1.15-4.17 0z"/><path d="M12 2v10m-3.5 3l3.5-3.5 3.5 3.5"/></svg>
        };

        const OBSTACLE_CATEGORIES = [
            { value: 'stairs', label: 'å°é˜¶/é«˜å·®' },
            { value: 'slope', label: 'å¡åº¦è¿‡é™¡' },
            { value: 'surface', label: 'è·¯é¢ä¸å¹³/å‘æ´¼' },
            { value: 'width', label: 'é€šé“è¿‡çª„' },
            { value: 'blocked', label: 'ç›²é“è¢«å ç”¨/é˜»æ–­' },
            { value: 'other', label: 'å…¶ä»–é—®é¢˜' },
        ];

        const MAP_ELEMENTS = {
            buildings: { name: "å»ºç­‘", layer: 'building', url: 'https://{s}.basemaps.cartocdn.com/rastertiles/dark_all/{z}/{x}/{y}{r}.png', icon: Icons.Building, query: `way["building"]` },
            roads: { name: "é“è·¯", layer: 'road', url: 'https://{s}.basemaps.cartocdn.com/rastertiles/voyager_labels_under/{z}/{x}/{y}{r}.png', icon: Icons.Road, query: `way["highway"]` },
            water: { name: "æ°´ç³»", layer: 'water', url: 'https://{s}.basemaps.cartocdn.com/rastertiles/light_all/{z}/{x}/{y}{r}.png', icon: Icons.Droplet, query: `relation["natural"="water"]; way["natural"="water"]` },
            plants: { name: "ç»¿æ¤", layer: 'green', url: 'https://{s}.basemaps.cartocdn.com/rastertiles/positron/{z}/{x}/{y}{r}.png', icon: Icons.TreePine, query: `way["leisure"="park"]; way["landuse"="grass"]` }
        };

        const TILE_LAYERS = {
            standard: { name: "æ ‡å‡†", url: "https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}{r}.png", attribution: '&copy; CARTO' },
            satellite: { name: "å«æ˜Ÿ", url: "https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}", attribution: '&copy; Esri' },
            simple: { name: "æç®€", url: "https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png", attribution: '&copy; CARTO' }
        };

        const INITIAL_LOCATIONS = [
            { name: "æ±Ÿå®‰æ ¡åŒº", coords: [30.556, 103.998], type: 'point' },
            { name: "å¹²å®¶æ²Ÿæ‘", coords: [30.365, 104.525], type: 'point' }
        ];

        const generateRandomName = () => {
            const adjs = ['çƒ­å¿ƒ', 'ç¥ç§˜', 'å¿«ä¹', 'å‹¤åŠ³', 'ä¸“ä¸š', 'é—ªç”µ'];
            const nouns = ['å¿—æ„¿è€…', 'è¡Œè€…', 'è§‚å¯Ÿå‘˜', 'æµ‹ç»˜å¸ˆ', 'å°æ¡¥äºº'];
            return adjs[Math.floor(Math.random()*adjs.length)] + nouns[Math.floor(Math.random()*nouns.length)] + '_' + Math.floor(Math.random()*1000);
        };

        const SafeTextarea = ({ initialValue, onSave, placeholder }) => {
            const textareaRef = useRef(null);
            const timerRef = useRef(null);

            useEffect(() => {
                if (textareaRef.current) {
                    textareaRef.current.value = initialValue || '';
                }
            }, [initialValue]);

            const handleInput = (e) => {
                const val = e.target.value;
                
                if (timerRef.current) clearTimeout(timerRef.current);
                timerRef.current = setTimeout(() => {
                    onSave(val);
                }, 800);
            };

            return (
                <textarea 
                    ref={textareaRef}
                    defaultValue={initialValue}
                    onInput={handleInput}
                    className="w-full border rounded p-2 h-20 text-sm" 
                    placeholder={placeholder}
                />
            );
        };

        // --- åœ°å›¾ç»„ä»¶ ---
        const MapView = React.memo(({ markers, selectedMarkerId, activeTool, onMapClick, onMarkerClick, onMapReady, activeBaseLayer, visibleTypes, currentUserId, customRegions, drawingPoints, activeElementFilters, currentLocationName }) => {
            const mapRef = useRef(null);
            const markersLayerRef = useRef(null);
            const regionsLayerRef = useRef(null);
            const drawingLayerRef = useRef(null);
            const tileLayerRef = useRef(null);
            const elementLayerRef = useRef(null);
            const onMapClickRef = useRef(onMapClick);
            const onMarkerClickRef = useRef(onMarkerClick);

            // é¿å…é‡å¤è¯·æ±‚
            const lastRequestBounds = useRef(null);

            useEffect(() => {
                onMapClickRef.current = onMapClick;
                onMarkerClickRef.current = onMarkerClick;
            }, [onMapClick, onMarkerClick]);

            useEffect(() => {
                if (!mapRef.current) {
                    const map = L.map('map-container', { center: INITIAL_LOCATIONS[0].coords, zoom: 16, zoomControl: false, tap: false });
                    
                    tileLayerRef.current = L.tileLayer(TILE_LAYERS[activeBaseLayer].url, { attribution: TILE_LAYERS[activeBaseLayer].attribution, maxZoom: 20 }).addTo(map);

                    elementLayerRef.current = L.layerGroup().addTo(map); // è¦ç´ å±‚åœ¨æœ€ä¸‹
                    regionsLayerRef.current = L.layerGroup().addTo(map);
                    drawingLayerRef.current = L.layerGroup().addTo(map);
                    markersLayerRef.current = L.layerGroup().addTo(map);
                    
                    mapRef.current = map;
                    if(onMapReady) onMapReady(map);

                    map.on('click', (e) => { if(onMapClickRef.current) onMapClickRef.current(e.latlng); });
                    
                    // ç›‘å¬åœ°å›¾ç§»åŠ¨ï¼Œå¦‚æœå¼€å¯äº†è¦ç´ ç­›é€‰ï¼Œåˆ™é‡æ–°åŠ è½½æ•°æ®
                    map.on('moveend', () => {
                        // è¿™é‡Œå¯ä»¥è§¦å‘é‡æ–°åŠ è½½ï¼Œä½†ä¸ºäº†ç®€å•èµ·è§ï¼Œæˆ‘ä»¬æš‚ä¸å®ç°è‡ªåŠ¨é‡è½½ï¼Œè€Œæ˜¯ä¾èµ–ç­›é€‰å™¨åˆ‡æ¢
                    });
                }
            }, []);

            // ç›‘å¬åº•å›¾åˆ‡æ¢
            useEffect(() => {
                if (mapRef.current && tileLayerRef.current) {
                    mapRef.current.removeLayer(tileLayerRef.current);
                    tileLayerRef.current = L.tileLayer(TILE_LAYERS[activeBaseLayer].url, { attribution: TILE_LAYERS[activeBaseLayer].attribution, maxZoom: 20 }).addTo(mapRef.current);
                    // ç¡®ä¿é¡ºåº
                    // if(elementLayerRef.current) elementLayerRef.current.bringToBack();
                }
            }, [activeBaseLayer]);

            // [æ ¸å¿ƒ] åŠ è½½çŸ¢é‡è¦ç´  (Overpass API)
            useEffect(() => {
                if (!mapRef.current || !elementLayerRef.current) return;
                
                elementLayerRef.current.clearLayers();
                document.body.classList.remove('scanning'); // åœæ­¢åŠ¨ç”»

                if (!activeElementFilters) return;

                const config = MAP_ELEMENTS[activeElementFilters];
                if (!config) return;

                const zoom = mapRef.current.getZoom();
                if (zoom < 14) {
                    // ç¼©æ”¾å¤ªå°ä¸åŠ è½½
                    return;
                }
                
                document.body.classList.add('scanning'); // å¼€å§‹åŠ¨ç”»

                const bounds = mapRef.current.getBounds();
                const bbox = `${bounds.getSouth()},${bounds.getWest()},${bounds.getNorth()},${bounds.getEast()}`;
                
                // æ„å»ºæŸ¥è¯¢è¯­å¥
                const query = `
                    [out:json][timeout:25];
                    (
                      ${config.query}(${bbox});
                    );
                    out geom;
                `;

                const fetchOverpass = async () => {
                    // å¢åŠ AbortControlleré˜²æ­¢è¯·æ±‚å †ç§¯
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 10000); // 10ç§’è¶…æ—¶

                    try {
                        const response = await fetch('https://overpass-api.de/api/interpreter', {
                            method: 'POST',
                            body: query,
                            signal: controller.signal
                        });
                        
                        if (!response.ok) throw new Error("Overpass API error");

                        // [å…³é”®] å…ˆè½¬æ–‡æœ¬ï¼Œé˜²æ­¢éJSONå“åº”å¯¼è‡´å´©æºƒ
                        const text = await response.text();
                        let data;
                        try {
                            data = JSON.parse(text);
                        } catch (jsonError) {
                            console.error("Invalid JSON from Overpass:", text.substring(0, 100));
                            throw new Error("Invalid JSON");
                        }
                        
                        if(data && data.elements) {
                            data.elements.forEach(el => {
                                let layer;
                                if (el.type === 'way' && el.geometry) {
                                    const latlngs = el.geometry.map(p => [p.lat, p.lon]);
                                    // æ ¹æ®æ˜¯å¦æœ‰å¡«å……è‰²å†³å®šç”»å¤šè¾¹å½¢è¿˜æ˜¯çº¿
                                    if (config.style.fillColor) {
                                        layer = L.polygon(latlngs, { ...config.style, stroke: false, interactive: false });
                                    } else {
                                        layer = L.polyline(latlngs, { ...config.style, interactive: false });
                                    }
                                }
                                if (layer) layer.addTo(elementLayerRef.current);
                            });
                        }
                    } catch (e) {
                        console.error("Overpass Fetch Error:", e);
                    } finally {
                        clearTimeout(timeoutId);
                        document.body.classList.remove('scanning');
                    }
                };

                fetchOverpass();

            }, [activeElementFilters]); // ä»…åœ¨ç­›é€‰å™¨å˜åŒ–æ—¶åŠ è½½ï¼Œé¿å…é¢‘ç¹è¯·æ±‚

            // æ¸²æŸ“åŒºåŸŸ
            useEffect(() => {
                if (!regionsLayerRef.current) return;
                regionsLayerRef.current.clearLayers();
                
                if(customRegions) {
                    customRegions.forEach(region => {
                        if(region.type === 'region' && region.points && region.points.length > 0) {
                            const isSelected = region.name === currentLocationName;
                            const polygon = L.polygon(region.points, { 
                                color: isSelected ? '#f59e0b' : '#3b82f6', 
                                weight: isSelected ? 4 : 2,
                                fillOpacity: isSelected ? 0.2 : 0.05,
                                dashArray: isSelected ? null : '5, 5'
                            });
                            polygon.bindTooltip(region.name, { permanent: true, direction: 'center', className: `region-tooltip ${isSelected ? 'font-bold text-yellow-600' : 'text-blue-500'}` });
                            
                            polygon.on('click', (e) => {
                                L.DomEvent.stopPropagation(e);
                                mapRef.current.fitBounds(polygon.getBounds());
                            });
                            polygon.addTo(regionsLayerRef.current);
                        }
                    });
                }
            }, [customRegions, currentLocationName]);

            useEffect(() => {
                if (!drawingLayerRef.current) return;
                drawingLayerRef.current.clearLayers();
                if (drawingPoints && drawingPoints.length > 0) {
                    L.polyline(drawingPoints, { color: '#ef4444', weight: 3, dashArray: '5, 10' }).addTo(drawingLayerRef.current);
                    drawingPoints.forEach(pt => {
                        L.circleMarker(pt, { radius: 4, color: '#ef4444', fillColor: '#fff', fillOpacity: 1 }).addTo(drawingLayerRef.current);
                    });
                    if (drawingPoints.length > 2) {
                        L.polygon(drawingPoints, { color: '#ef4444', fillOpacity: 0.1, stroke: false }).addTo(drawingLayerRef.current);
                    }
                }
            }, [drawingPoints]);

            useEffect(() => {
                if (!mapRef.current || !markersLayerRef.current) return;
                markersLayerRef.current.clearLayers();
                markers.forEach(m => {
                    if (!m.lat || !m.lng) return;
                    if (!visibleTypes[m.type]) return;

                    let colorClass;
                    if (m.status === 'fixed') {
                        colorClass = 'marker-fixed';
                    } else {
                        colorClass = m.type === 'obstacle' ? 'marker-obstacle' : m.type === 'facility' ? 'marker-facility' : 'marker-experience';
                    }

                    const symbol = m.type === 'obstacle' ? '!' : m.type === 'facility' ? 'âœ“' : 'i';
                    const isMine = m.userId === currentUserId; 
                    const ownershipClass = isMine ? 'marker-mine' : 'marker-others';
                    const selectedClass = selectedMarkerId === m.id ? 'marker-selected' : '';

                    const icon = L.divIcon({
                        className: 'custom-div-icon',
                        html: `<div class="marker-pin ${colorClass} ${ownershipClass} ${selectedClass}"><i>${symbol}</i></div>`,
                        iconSize: [30, 42], iconAnchor: [15, 42]
                    });
                    const marker = L.marker([m.lat, m.lng], { icon: icon });
                    marker.on('click', (e) => {
                        L.DomEvent.stopPropagation(e);
                        if(onMarkerClickRef.current) onMarkerClickRef.current(m.id);
                        mapRef.current.panTo([m.lat, m.lng]); 
                    });
                    marker.addTo(markersLayerRef.current);
                });
            }, [markers, selectedMarkerId, visibleTypes, currentUserId]);

            useEffect(() => {
                const el = document.getElementById('map-container');
                if(el) {
                    if (activeTool) el.classList.add('map-crosshair'); else el.classList.remove('map-crosshair');
                }
            }, [activeTool]);

            return (
                <>
                    <div id="map-container"></div>
                    <div className={`scanning-bar ${activeElementFilters ? 'block' : 'hidden'}`}></div>
                </>
            );
        });

        const App = () => {
            const [markers, setMarkers] = useState([]);
            const [activeTool, setActiveTool] = useState(null);
            const [selectedMarkerId, setSelectedMarkerId] = useState(null);
            const [showSidebar, setShowSidebar] = useState(true);
            const [showStats, setShowStats] = useState(false);
            const [isConnected, setIsConnected] = useState(false);
            const [userName, setUserName] = useState('');
            const [currentUserId, setCurrentUserId] = useState('');
            
            const [activeBaseLayer, setActiveBaseLayer] = useState('standard');
            const [visibleTypes, setVisibleTypes] = useState({ obstacle: true, facility: true, experience: true });
            
            const [searchQuery, setSearchQuery] = useState('');
            const [customLocations, setCustomLocations] = useState(INITIAL_LOCATIONS);
            const [currentLocationName, setCurrentLocationName] = useState(INITIAL_LOCATIONS[0].name);
            const [isEditingLocName, setIsEditingLocName] = useState(false);

            const [drawingPoints, setDrawingPoints] = useState([]);

            const mapInstanceRef = useRef(null);
            const markerImageInputRef = useRef(null);
            const [aiAnalysisResult, setAiAnalysisResult] = useState(null);
            const [isAiAnalyzing, setIsAiAnalyzing] = useState(false);
            
            const [activeElementFilters, setActiveElementFilters] = useState(null); 

            useEffect(() => {
                let savedName = localStorage.getItem('user_nickname');
                let savedId = localStorage.getItem('user_id');
                if (!savedId) { savedId = 'uid_' + Math.random().toString(36).substr(2, 9); localStorage.setItem('user_id', savedId); }
                if (!savedName) { savedName = generateRandomName(); localStorage.setItem('user_nickname', savedName); }
                setCurrentUserId(savedId);
                setUserName(savedName);
                
                const savedLocs = localStorage.getItem('custom_locations');
                if(savedLocs) setCustomLocations(JSON.parse(savedLocs));
            }, []);

            const handleNameChange = (e) => {
                const newName = e.target.value;
                setUserName(newName);
                localStorage.setItem('user_nickname', newName);
            };

            useEffect(() => {
                if (!isOfflineMode && auth) {
                    auth.signInAnonymously().catch(e => console.error(e));
                    auth.onAuthStateChanged(user => {
                        setIsConnected(!!user);
                        if (user) {
                            db.collection('markers').onSnapshot(snap => {
                                const loaded = snap.docs.map(doc => ({ id: doc.id, ...doc.data() })).filter(m => m.lat && m.lng); 
                                setMarkers(loaded);
                            }, err => { if(err.code==='permission-denied') alert("ğŸ”´ æƒé™ä¸è¶³"); });
                        }
                    });
                } else {
                    const saved = localStorage.getItem('offline_markers');
                    if (saved) setMarkers(JSON.parse(saved).filter(m => m.lat && m.lng));
                }
            }, []);

            const updateLocalMarker = async (id, updates) => {
                setMarkers(prev => prev.map(m => m.id === id ? { ...m, ...updates } : m));
                if (!isOfflineMode && db && isConnected && !id.startsWith('local_')) {
                     const cleanUpdates = JSON.parse(JSON.stringify(updates));
                     db.collection('markers').doc(id).update(cleanUpdates).catch(e => console.error("åŒæ­¥å¤±è´¥", e));
                } else {
                    setTimeout(() => {
                        const currentMarkers = JSON.parse(localStorage.getItem('offline_markers') || '[]');
                        const newMarkers = currentMarkers.map(m => m.id === id ? { ...m, ...updates } : m);
                        localStorage.setItem('offline_markers', JSON.stringify(newMarkers));
                    }, 0);
                }
            };

            const saveMarker = async (data) => {
                const cleanData = JSON.parse(JSON.stringify(data));
                const tempId = 'temp_' + Date.now();
                const optimisticMarker = { ...cleanData, id: tempId };
                setMarkers(prev => [...prev, optimisticMarker]);

                if (!isOfflineMode && db && isConnected) {
                    try { 
                        const ref = await db.collection('markers').add(cleanData); 
                        setMarkers(prev => prev.map(m => m.id === tempId ? { ...m, id: ref.id } : m));
                        if (selectedMarkerId === tempId) setSelectedMarkerId(ref.id);
                        return ref.id; 
                    } 
                    catch (e) { return null; }
                } else {
                    const newId = 'local_' + Date.now();
                    setMarkers(prev => prev.map(m => m.id === tempId ? { ...m, id: newId } : m));
                    const currentSaved = JSON.parse(localStorage.getItem('offline_markers') || '[]');
                    localStorage.setItem('offline_markers', JSON.stringify([...currentSaved, { ...cleanData, id: newId }]));
                    return newId;
                }
            };

            const deleteLocalMarker = async (id) => {
                 if (!confirm("ç¡®å®šåˆ é™¤å—ï¼Ÿ")) return;
                 setMarkers(prev => prev.filter(m => m.id !== id));
                 setSelectedMarkerId(null);

                 if (!isOfflineMode && db && isConnected && !id.startsWith('local_')) {
                     db.collection('markers').doc(id).delete().catch(e => alert("åˆ é™¤å¤±è´¥"));
                } else {
                    const currentSaved = JSON.parse(localStorage.getItem('offline_markers') || '[]');
                    const newSaved = currentSaved.filter(m => m.id !== id);
                    localStorage.setItem('offline_markers', JSON.stringify(newSaved));
                }
            };

            const handleMapClick = async (latlng) => {
                if (activeTool === 'draw-region') {
                    setDrawingPoints(prev => [...prev, [latlng.lat, latlng.lng]]);
                    return;
                }

                if (!activeTool) return; 
                if (selectedMarkerId) { setSelectedMarkerId(null); return; }

                const { lat, lng } = latlng;
                const newData = {
                    lat, lng, type: activeTool, description: '', author: userName, userId: currentUserId, timestamp: Date.now(),
                    category: activeTool === 'obstacle' ? 'other' : null,
                    severity: activeTool === 'obstacle' ? 'medium' : null,
                    rating: activeTool === 'experience' ? 3 : null,
                    imageUrl: '',
                    status: 'pending',
                    aiResult: null
                };
                const id = await saveMarker(newData);
                if (id) { setActiveTool(null); setSelectedMarkerId(id); }
            };

            const finishDrawing = () => {
                if (drawingPoints.length < 3) {
                    alert("è¯·è‡³å°‘é€‰æ‹© 3 ä¸ªç‚¹æ¥æ„æˆä¸€ä¸ªåŒºåŸŸ");
                    return;
                }
                const name = prompt("è¯·è¾“å…¥åŒºåŸŸåç§° (å¦‚: è¥¿å›­å®¿èˆåŒº):", "æ–°åŒºåŸŸ");
                if (name) {
                    const newRegion = { name, type: 'region', points: drawingPoints };
                    const newLocs = [...customLocations, newRegion];
                    setCustomLocations(newLocs);
                    localStorage.setItem('custom_locations', JSON.stringify(newLocs));
                    if(mapInstanceRef.current) {
                        const polygon = L.polygon(drawingPoints);
                        mapInstanceRef.current.fitBounds(polygon.getBounds());
                    }
                    setCurrentLocationName(name);
                }
                setDrawingPoints([]);
                setActiveTool(null);
            };

            const deleteLocation = (locName) => {
                if(confirm(`ç¡®å®šè¦åˆ é™¤ "${locName}" å—ï¼Ÿ`)) {
                    const newLocs = customLocations.filter(l => l.name !== locName);
                    setCustomLocations(newLocs);
                    localStorage.setItem('custom_locations', JSON.stringify(newLocs));
                    if(currentLocationName === locName) setCurrentLocationName("æœªé€‰æ‹©");
                }
            };

            const handleMarkerImageUpload = (e, id) => {
                const file = e.target.files[0];
                if (file) {
                    const r = new FileReader();
                    r.onload = (ev) => updateLocalMarker(id, { imageUrl: ev.target.result });
                    r.readAsDataURL(file);
                }
            };

            const exportData = () => {
                const headers = ["ID", "ç±»å‹", "çŠ¶æ€", "æè¿°", "ä½œè€…", "æ—¶é—´", "ç»åº¦", "çº¬åº¦", "AIåˆ†æç»“æœ"];
                const rows = markers.map(m => [
                    m.id,
                    m.type === 'obstacle' ? 'éšœç¢' : m.type === 'facility' ? 'è®¾æ–½' : 'ä½“éªŒ',
                    m.status || 'pending',
                    `"${(m.description || '').replace(/"/g, '""')}"`, 
                    m.author,
                    new Date(m.timestamp).toLocaleString(),
                    m.lng,
                    m.lat,
                    `"${(m.aiResult || '').replace(/"/g, '""')}"`
                ]);
                const csvContent = [headers.join(','), ...rows.map(row => row.join(','))].join('\n');
                const blob = new Blob(["\uFEFF" + csvContent], { type: 'text/csv;charset=utf-8;' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a'); a.href = url; a.download = `å·å°æ¡¥è°ƒç ”æ•°æ®_${new Date().toLocaleDateString()}.csv`; a.click();
            };

            const handleSaveSnapshot = () => {
                alert("æ­£åœ¨ç”Ÿæˆæˆªå›¾...");
                const mapContainer = document.getElementById('map-container');
                document.querySelectorAll('.ui-layer').forEach(el => el.style.visibility = 'hidden');
                html2canvas(mapContainer, { useCORS: true, allowTaint: false, logging: false, width: mapContainer.offsetWidth, height: mapContainer.offsetHeight }).then(canvas => {
                    document.querySelectorAll('.ui-layer').forEach(el => el.style.visibility = 'visible');
                    const ctx = canvas.getContext('2d');
                    markers.forEach(m => {
                        if(!mapInstanceRef.current || !visibleTypes[m.type]) return;
                        const point = mapInstanceRef.current.latLngToContainerPoint([m.lat, m.lng]);
                        ctx.beginPath(); ctx.arc(point.x, point.y - 15, 15, 0, 2 * Math.PI);
                        if (m.status === 'fixed') ctx.fillStyle = '#64748b';
                        else ctx.fillStyle = m.type === 'obstacle' ? '#ef4444' : m.type === 'facility' ? '#22c55e' : '#3b82f6';
                        ctx.fill(); ctx.strokeStyle = 'white'; ctx.lineWidth = 3; ctx.stroke();
                        ctx.fillStyle = 'white'; ctx.font = 'bold 16px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                        const symbol = m.type === 'obstacle' ? '!' : m.type === 'facility' ? 'âœ“' : 'i';
                        ctx.fillText(symbol, point.x, point.y - 15);
                        ctx.beginPath(); ctx.moveTo(point.x - 10, point.y - 5); ctx.lineTo(point.x + 10, point.y - 5); ctx.lineTo(point.x, point.y + 10);
                        if (m.status === 'fixed') ctx.fillStyle = '#64748b';
                        else ctx.fillStyle = m.type === 'obstacle' ? '#ef4444' : m.type === 'facility' ? '#22c55e' : '#3b82f6'; ctx.fill();
                    });
                    const link = document.createElement('a'); link.download = `å·å°æ¡¥_å¿«ç…§_${Date.now()}.png`; link.href = canvas.toDataURL(); link.click();
                }).catch(err => {
                    document.querySelectorAll('.ui-layer').forEach(el => el.style.visibility = 'visible');
                    alert("æˆªå›¾å¤±è´¥");
                });
            };

            const flyToSchool = () => { 
                if (mapInstanceRef.current) {
                    mapInstanceRef.current.flyTo(INITIAL_LOCATIONS[0].coords, 16); 
                    setCurrentLocationName(INITIAL_LOCATIONS[0].name);
                }
            }
            const toggleLayer = (type) => { setVisibleTypes(prev => ({...prev, [type]: !prev[type]})); };

            const handleLocationChange = (location) => {
                if (mapInstanceRef.current) {
                    if(location.type === 'region') {
                        const polygon = L.polygon(location.points);
                        mapInstanceRef.current.fitBounds(polygon.getBounds());
                    } else {
                        mapInstanceRef.current.flyTo(location.coords, 16);
                    }
                    setCurrentLocationName(location.name);
                }
            };

            const saveCurrentViewAsLocation = () => {
                if(mapInstanceRef.current) {
                    const center = mapInstanceRef.current.getCenter();
                    const newLoc = { name: currentLocationName, coords: [center.lat, center.lng], type: 'point' };
                    const exists = customLocations.find(l => l.name === currentLocationName);
                    let newLocs;
                    if(exists) {
                        newLocs = customLocations.map(l => l.name === currentLocationName ? newLoc : l);
                        alert(`å·²æ›´æ–° "${currentLocationName}"`);
                    } else {
                        newLocs = [...customLocations, newLoc];
                        alert(`å·²ä¿å­˜ "${currentLocationName}"`);
                    }
                    setCustomLocations(newLocs);
                    localStorage.setItem('custom_locations', JSON.stringify(newLocs));
                    setIsEditingLocName(false);
                }
            };

            const handleSearch = async () => {
                if (!searchQuery.trim()) return;
                try {
                    const response = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(searchQuery)}`);
                    const data = await response.json();
                    if (data && data.length > 0) {
                        const { lat, lon, display_name } = data[0];
                        if (mapInstanceRef.current) {
                            mapInstanceRef.current.flyTo([lat, lon], 16);
                            const simpleName = display_name.split(',')[0];
                            setCurrentLocationName(simpleName); 
                            setSearchQuery(''); 
                        }
                    } else { alert("æœªæ‰¾åˆ°è¯¥åœ°ç‚¹"); }
                } catch (e) { console.error(e); }
            };

            const handleLocateMe = () => {
                if (mapInstanceRef.current) {
                    mapInstanceRef.current.locate({setView: true, maxZoom: 18});
                }
            };
            
            const analyzeMarker = async (marker) => {
                if (!GEMINI_API_KEY || !AI_ENDPOINT_URL) {
                    alert("è¯·åœ¨ä»£ç ä¸­é…ç½® API Key å’Œ Endpoint URL (æ”¯æŒ Gemini æˆ– Qwen)");
                    return;
                }

                if (!marker.imageUrl) {
                    alert("è¯·å…ˆä¸Šä¼ ç°åœºå›¾ç‰‡æ‰èƒ½è¿›è¡Œ AI åˆ†æã€‚");
                    return;
                }
                
                setIsAiAnalyzing(true);
                setAiAnalysisResult("æ­£åœ¨è¿›è¡Œå¤šæ¨¡æ€æ™ºèƒ½åˆ†æ...");
                
                const promptText = `
                    ä½ æ˜¯ä¸€ä¸ªä¸“ä¸šçš„æ— éšœç¢ç¯å¢ƒè¯„ä¼°å¸ˆï¼Œè¯·åˆ†æä»¥ä¸‹å›¾ç‰‡å’Œæ–‡å­—æè¿°ï¼Œå¹¶ç»™å‡ºä¸“ä¸šçš„æ— éšœç¢æ”¹é€ å»ºè®®å’Œé£é™©è¯„ä¼°ã€‚
                    
                    **ç”¨æˆ·æè¿°**: ${marker.description}
                    **éšœç¢ç±»å‹ (ç”¨æˆ·åˆåˆ¤)**: ${marker.category || 'æœªåˆ†ç±»'}
                    
                    **è¯·è¿”å›ä»¥ä¸‹ç»“æ„åŒ–çš„åˆ†æ**:
                    1. éšœç¢ç‚¹ä½ç¡®è®¤ (æ ¹æ®å›¾ç‰‡)ï¼šæ˜¯/å¦æ˜¯æ— éšœç¢è®¾æ–½ç¼ºå¤±ï¼Ÿ
                    2. ä¸¥é‡ç¨‹åº¦åˆ†æ (1-5åˆ†): 5åˆ†ä¸ºæœ€é«˜é£é™©ã€‚
                    3. æ”¹é€ å»ºè®® (ä¸è¶…è¿‡100å­—): é’ˆå¯¹è¿™ä¸ªç‚¹ä½ï¼Œä»å»ºç­‘å­¦è§’åº¦æå‡ºå¯è¡Œæ€§å»ºè®®ã€‚
                    4. ç»“è®ºæ€»ç»“ï¼šä¸€å¥æ¦‚æ‹¬ã€‚
                `;

                const base64Data = marker.imageUrl.split(',')[1];
                const mimeType = marker.imageUrl.split(',')[0].split(':')[1].split(';')[0];
                
                const payload = {
                    contents: [
                        {
                            parts: [
                                { text: promptText },
                                { inlineData: { mimeType: mimeType, data: base64Data } }
                            ]
                        }
                    ],
                };

                try {
                    const url = `${AI_ENDPOINT_URL}?key=${GEMINI_API_KEY}`;
                    const response = await fetch(url, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (!response.ok) {
                        throw new Error(`API Error: ${response.status} ${response.statusText}`);
                    }

                    const result = await response.json();
                    const aiText = result.candidates?.[0]?.content?.parts?.[0]?.text || "AIæœªè¿”å›æœ‰æ•ˆå†…å®¹ï¼Œè¯·æ£€æŸ¥APIè®¾ç½®ã€‚";
                    
                    setAiAnalysisResult(aiText);
                    updateLocalMarker(marker.id, { aiResult: aiText });
                } catch (error) {
                    console.error("AI Analysis Failed:", error);
                    setAiAnalysisResult("AIåˆ†æå¤±è´¥ã€‚è¯·æ£€æŸ¥APIå¯†é’¥ã€ç½‘ç»œä»£ç†å’Œé…ç½®URLæ˜¯å¦æ­£ç¡®ã€‚");
                } finally {
                    setIsAiAnalyzing(false);
                }
            };

            const toggleElementFilter = (key) => {
                setActiveElementFilters(prev => (prev === key ? null : key));
                
                let newBaseKey = 'standard';
                if (key === 'buildings') newBaseKey = 'satellite'; 
                else if (key === 'roads') newBaseKey = 'standard'; 
                else if (key === 'water') newBaseKey = 'simple';   
                else if (key === 'plants') newBaseKey = 'standard'; 
                
                setActiveBaseLayer(newBaseKey);
            };

            const renderDetailForm = () => {
                const m = markers.find(mk => mk.id === selectedMarkerId);
                if (!m) return null;
                const isMine = m.userId === currentUserId;

                return (
                    <div className="absolute top-4 right-4 w-80 bg-white rounded-xl shadow-2xl border border-slate-200 z-[2000] overflow-hidden flex flex-col max-h-[90vh] pointer-events-auto">
                        <div className={`p-4 text-white flex justify-between items-center ${m.status === 'fixed' ? 'bg-slate-500' : (m.type === 'obstacle' ? 'bg-red-500' : m.type === 'facility' ? 'bg-green-500' : 'bg-blue-500')}`}>
                            <span className="font-bold flex gap-2 items-center">è¯¦æƒ…ç¼–è¾‘</span>
                            <button onClick={() => setSelectedMarkerId(null)}><Icons.X size={18}/></button>
                        </div>
                        <div className="p-4 space-y-4 overflow-y-auto text-sm">
                            <div className="flex justify-between items-center">
                                <span className="text-xs text-slate-400 flex items-center gap-1"><Icons.User size={12}/> {isMine ? 'æˆ‘' : m.author}</span>
                                {!isMine && <span className="text-[10px] bg-gray-100 px-2 py-1 rounded text-gray-500">ä»–äººè´¡çŒ®</span>}
                            </div>

                            <div>
                                <label className="block font-bold mb-1">å½“å‰çŠ¶æ€</label>
                                <select value={m.status || 'pending'} onChange={e => updateLocalMarker(m.id, {status: e.target.value})} className="w-full border rounded p-2 bg-slate-50">
                                    <option value="pending">å¾…å¤„ç†</option>
                                    <option value="in_progress">æ•´æ”¹ä¸­</option>
                                    <option value="fixed">å·²ä¿®å¤ (åœ°å›¾ä¸Šå˜ç°)</option>
                                </select>
                            </div>
                            
                            {m.type === 'obstacle' && (
                                <div>
                                    <label className="block font-bold mb-1">éšœç¢ç±»å‹</label>
                                    <select value={m.category || 'other'} onChange={e => updateLocalMarker(m.id, {category: e.target.value})} className="w-full border rounded p-2 bg-slate-50">
                                        {OBSTACLE_CATEGORIES.map(c => <option key={c.value} value={c.value}>{c.label}</option>)}
                                    </select>
                                </div>
                            )}
                            {m.type === 'experience' && (
                                <div>
                                    <label className="block font-bold mb-1">è¯„åˆ†</label>
                                    <div className="flex gap-1">
                                        {[1,2,3,4,5].map(s => (
                                            <button key={s} onClick={() => updateLocalMarker(m.id, {rating: s})} className={ (m.rating||0)>=s ? 'text-yellow-400' : 'text-slate-300'}>
                                                <Icons.Star size={24} fill="currentColor"/>
                                            </button>
                                        ))}
                                    </div>
                                </div>
                            )}
                            
                            <SafeTextarea key={m.id} initialValue={m.description} onSave={(val) => updateLocalMarker(m.id, {description: val})} placeholder="è¯·æè¿°ç°åœºæƒ…å†µ..."/>

                            <div className="border-t pt-3">
                                <div className="flex justify-between items-center mb-2">
                                    <span className="font-bold">ç…§ç‰‡</span>
                                    <button onClick={() => markerImageInputRef.current.click()} className="text-blue-600 flex items-center gap-1"><Icons.Upload size={12}/>ä¸Šä¼ </button>
                                    <input type="file" ref={markerImageInputRef} onChange={e => handleMarkerImageUpload(e, m.id)} className="hidden" accept="image/*"/>
                                </div>
                                {m.imageUrl ? (
                                    <div className="relative h-32 bg-slate-100 rounded overflow-hidden group">
                                        <img src={m.imageUrl} className="w-full h-full object-cover"/>
                                        <button onClick={() => updateLocalMarker(m.id, {imageUrl: ''})} className="absolute top-1 right-1 bg-red-500 text-white rounded-full p-1 opacity-0 group-hover:opacity-100"><Icons.X size={12}/></button>
                                    </div>
                                ) : <div className="h-32 bg-slate-50 border-dashed border-2 flex items-center justify-center text-slate-400 cursor-pointer" onClick={() => markerImageInputRef.current.click()}><Icons.Image size={24}/></div>}
                            </div>
                            
                            {/* AI åˆ†æéƒ¨åˆ† */}
                            <div className="border-t pt-3 space-y-2">
                                <button 
                                    onClick={() => analyzeMarker(m)}
                                    disabled={isAiAnalyzing || !m.imageUrl}
                                    className={`w-full flex items-center justify-center gap-2 py-2 rounded-lg text-xs font-bold transition-colors ${isAiAnalyzing ? 'bg-gray-300 text-gray-600 cursor-not-allowed' : 'bg-green-500 text-white hover:bg-green-600 disabled:bg-gray-400'}`}
                                >
                                    {isAiAnalyzing ? (
                                        <>
                                            <svg className="animate-spin h-4 w-4 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4" className="opacity-25"></circle><path fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z" className="opacity-75"></path></svg>
                                            AI æ­£åœ¨åˆ†æ...
                                        </>
                                    ) : (
                                        <><Icons.Zap size={16}/> AI æ™ºèƒ½åˆ†æ</>
                                    )}
                                </button>
                                
                                {(m.aiResult || aiAnalysisResult) && (
                                    <div className="bg-green-50 p-3 rounded-lg border border-green-200">
                                        <h4 className="text-xs font-bold text-green-700 mb-1">AI åˆ†æç»“æœï¼š</h4>
                                        <p className="text-[10px] text-green-800 whitespace-pre-wrap">
                                            {m.aiResult || aiAnalysisResult}
                                        </p>
                                    </div>
                                )}
                            </div>
                            {/* åº•éƒ¨æŒ‰é’® */}
                            <div className="border-t pt-3 flex justify-between">
                                <button onClick={() => deleteLocalMarker(m.id)} className="text-red-500 hover:bg-red-50 p-2 rounded">åˆ é™¤</button>
                                <button onClick={() => setSelectedMarkerId(null)} className="bg-slate-800 text-white px-3 py-1 rounded">å®Œæˆ</button>
                            </div>
                        </div>
                    </div>
                );
            };

            const renderStatsModal = () => {
                if (!showStats) return null;
                const total = markers.length;
                const obstacleCount = markers.filter(m => m.type === 'obstacle').length;
                const facilityCount = markers.filter(m => m.type === 'facility').length;
                const highSeverityCount = markers.filter(m => m.type === 'obstacle' && m.severity === 'high').length;
                let healthScore = 60 + (facilityCount * 5) - (obstacleCount * 2) - (highSeverityCount * 5);
                healthScore = Math.max(0, Math.min(100, healthScore));
                const contributorMap = {};
                markers.forEach(m => { const name = m.author || 'åŒ¿å'; contributorMap[name] = (contributorMap[name] || 0) + 1; });
                const leaderboard = Object.entries(contributorMap).sort((a, b) => b[1] - a[1]).slice(0, 3);

                return (
                    <div className="fixed inset-0 z-[3000] bg-black/50 flex items-center justify-center p-4 pointer-events-auto">
                        <div className="bg-white rounded-xl w-full max-w-2xl p-6 relative flex flex-col max-h-[90vh]">
                            <button onClick={() => setShowStats(false)} className="absolute top-4 right-4"><Icons.X/></button>
                            <h2 className="text-xl font-bold mb-6 flex gap-2 items-center text-slate-800"><Icons.BarChart2 className="text-blue-600"/> æ ¡å›­æ•°æ®æ´å¯Ÿ</h2>
                            <div className="overflow-y-auto space-y-6 pr-2">
                                <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                                    <div className="bg-blue-50 p-5 rounded-2xl border border-blue-100 flex flex-col items-center justify-center relative">
                                        <div className="text-sm text-blue-500 font-bold mb-1">æ— éšœç¢å¥åº·æŒ‡æ•°</div>
                                        <div className="text-5xl font-black text-blue-700 z-10">{healthScore}</div>
                                        <div className="w-full bg-gray-200 h-2 rounded-full mt-3"><div className="h-full bg-blue-500 gauge-anim" style={{width: `${healthScore}%`}}></div></div>
                                    </div>
                                    <div className="bg-red-50 p-5 rounded-2xl border border-red-100">
                                        <div className="flex justify-between mb-4"><span className="text-sm font-bold text-red-600 flex gap-1"><Icons.AlertTriangle size={16}/> ä¸¥é‡é¢„è­¦</span><span className="text-2xl font-black text-red-600">{highSeverityCount}</span></div>
                                        <div className="text-xs text-red-800">ä¸¥é‡éšœç¢å æ¯”: {obstacleCount>0?((highSeverityCount/obstacleCount)*100).toFixed(0):0}%</div>
                                    </div>
                                    <div className="bg-yellow-50 p-5 rounded-2xl border border-yellow-100">
                                        <div className="text-sm font-bold text-yellow-700 mb-3 flex items-center gap-1"><Icons.Trophy size={16}/> è´¡çŒ®æ¦œ</div>
                                        <div className="space-y-2">
                                            {leaderboard.map((u, i) => (
                                                <div key={u[0]} className="flex justify-between text-xs bg-white/50 p-2 rounded">
                                                    <div className="flex gap-2"><span className={`w-4 h-4 rounded-full flex justify-center text-[10px] font-bold ${i===0?'bg-yellow-400 text-white':'bg-gray-300 text-white'}`}>{i+1}</span><span className="truncate max-w-[80px]">{u[0]}</span></div>
                                                    <span className="font-bold text-yellow-600">{u[1]}</span>
                                                </div>
                                            ))}
                                        </div>
                                    </div>
                                </div>
                                
                                <div className="bg-slate-50 p-4 rounded-xl border border-slate-200">
                                    <h3 className="text-sm font-bold text-slate-700 mb-3 flex items-center gap-2"><Icons.PieChart size={16}/> éšœç¢ç±»å‹åˆ†å¸ƒ</h3>
                                    <div className="space-y-3">
                                        {OBSTACLE_CATEGORIES.map(cat => {
                                            const count = markers.filter(m => m.type === 'obstacle' && m.category === cat.value).length;
                                            const percent = obstacleCount > 0 ? (count / obstacleCount) * 100 : 0;
                                            return (
                                                <div key={cat.value}>
                                                    <div className="flex justify-between text-xs mb-1"><span>{cat.label}</span><span className="text-slate-400">{count}å¤„</span></div>
                                                    <div className="w-full bg-slate-200 h-1.5 rounded-full"><div className="bg-blue-500 h-1.5 rounded-full transition-all duration-500" style={{width: `${percent}%`}}></div></div>
                                                </div>
                                            )
                                        })}
                                    </div>
                                </div>
                                
                                <div className="grid grid-cols-3 gap-4">
                                    <div className="bg-blue-50 p-3 rounded text-center"><div className="text-xl font-bold text-blue-600">{total}</div><div className="text-xs text-blue-400">æ€»æ ‡è®°</div></div>
                                    <div className="bg-green-50 p-3 rounded text-center"><div className="text-xl font-bold text-green-600">{facilityCount}</div><div className="text-xs text-green-400">è®¾æ–½</div></div>
                                    <div className="bg-red-50 p-3 rounded text-center"><div className="text-xl font-bold text-red-600">{obstacleCount}</div><div className="text-xs text-red-400">éšœç¢</div></div>
                                </div>
                            </div>
                            <div className="text-center mt-4"><button onClick={exportData} className="text-blue-600 text-sm hover:underline">å¯¼å‡ºæ•°æ®</button></div>
                        </div>
                    </div>
                );
            };

            return (
                <div className="flex flex-col md:flex-row h-screen bg-slate-50 text-slate-900 font-sans overflow-hidden relative">
                    <MapView 
                        markers={markers} selectedMarkerId={selectedMarkerId} activeTool={activeTool} onMapClick={handleMapClick} onMarkerClick={setSelectedMarkerId} onMapReady={(map) => mapInstanceRef.current = map}
                        activeBaseLayer={activeBaseLayer} visibleTypes={visibleTypes} currentUserId={currentUserId} customRegions={customLocations} drawingPoints={drawingPoints} activeElementFilters={activeElementFilters} currentLocationName={currentLocationName}
                    />
                    <div className="ui-layer flex h-full pointer-events-none">
                        <div className={`${showSidebar?'w-80':'w-0'} bg-white border-r flex flex-col transition-all shadow-xl pointer-events-auto overflow-hidden`}>
                            <div className="p-5 border-b">
                                <h1 className="text-xl font-bold flex gap-2 text-slate-800"><span className="text-blue-600"><Icons.Navigation/></span> å·å°æ¡¥ | å®æ—¶ç‰ˆ</h1>
                                <div className="mt-2 flex items-center gap-2 text-xs">
                                    {isConnected ? <span className="text-green-600 flex gap-1"><Icons.Wifi size={14}/> åœ¨çº¿</span> : <span className="text-slate-400 flex gap-1"><Icons.WifiOff size={14}/> ç¦»çº¿</span>}
                                    <input value={userName} onChange={handleNameChange} className="border-b w-24 bg-transparent outline-none font-bold text-slate-700" placeholder="ä½ çš„æ˜µç§°"/>
                                </div>
                            </div>
                            <div className="flex-1 overflow-y-auto p-4 space-y-6">
                                <div>
                                    <h3 className="text-xs font-bold text-slate-400 uppercase mb-2">è°ƒç ”ç‚¹ä½ç®¡ç†</h3>
                                    <div className="flex flex-col gap-2">
                                        <div className="flex flex-wrap gap-2 bg-slate-100 p-2 rounded-lg">
                                            {customLocations.map(loc => (
                                                <div key={loc.name} className="relative group">
                                                    <button 
                                                        onClick={() => handleLocationChange(loc)}
                                                        className={`px-2 py-1 text-xs rounded-md transition-all border pr-4 ${currentLocationName === loc.name ? 'bg-white border-blue-300 text-blue-600 font-bold shadow-sm' : 'bg-transparent border-transparent text-slate-500 hover:bg-white/50'}`}
                                                    >
                                                        {loc.name}
                                                    </button>
                                                    <button 
                                                        onClick={(e) => { e.stopPropagation(); deleteLocation(loc.name); }}
                                                        className="absolute top-0 right-0 p-0.5 text-slate-400 hover:text-red-500 opacity-0 group-hover:opacity-100 transition-opacity"
                                                    >
                                                        <Icons.X size={10}/>
                                                    </button>
                                                </div>
                                            ))}
                                        </div>
                                        
                                        <button onClick={handleLocateMe} className="w-full flex items-center justify-center gap-2 bg-blue-600 text-white py-2 rounded-lg hover:bg-blue-700 transition-all text-xs font-bold shadow-md">
                                            <Icons.Target size={16}/> å®šä½åˆ°æˆ‘çš„ä½ç½®
                                        </button>

                                        <div className="flex items-center gap-2 bg-white border rounded-md px-2 py-1 mt-1">
                                            <Icons.Search size={14} className="text-slate-400"/>
                                            <input type="text" value={searchQuery} onChange={(e) => setSearchQuery(e.target.value)} onKeyDown={(e) => e.key === 'Enter' && handleSearch()} className="w-full text-xs outline-none bg-transparent" placeholder="æœåœ°ç‚¹..."/>
                                            <button onClick={handleSearch} className="text-blue-500 text-xs whitespace-nowrap hover:underline">å‰å¾€</button>
                                        </div>
                                        <div className="flex items-center justify-between mt-2 border-t pt-2">
                                            <div className="flex items-center gap-1 overflow-hidden">
                                                <Icons.MapPin size={14} className="text-blue-500 shrink-0"/>
                                                {isEditingLocName ? (
                                                    <input value={currentLocationName} onChange={(e) => setCurrentLocationName(e.target.value)} onBlur={saveCurrentViewAsLocation} onKeyDown={(e) => e.key === 'Enter' && saveCurrentViewAsLocation()} className="text-xs border-b border-blue-300 outline-none bg-transparent w-full" autoFocus/>
                                                ) : <span className="text-xs font-bold text-slate-700 truncate cursor-pointer" onClick={() => setIsEditingLocName(true)}>{currentLocationName}</span>}
                                                <button onClick={() => setIsEditingLocName(!isEditingLocName)} className="text-slate-400 hover:text-blue-500"><Icons.Edit2 size={12}/></button>
                                            </div>
                                            <button onClick={saveCurrentViewAsLocation} className="text-[10px] bg-blue-50 text-blue-600 px-2 py-1 rounded hover:bg-blue-100 flex items-center gap-1"><Icons.Save size={12}/> ä¿å­˜è§†è§’</button>
                                        </div>
                                    </div>
                                </div>

                                {activeTool === 'draw-region' ? (
                                    <div className="bg-blue-50 p-3 rounded-lg border border-blue-200 animate-pulse">
                                        <h3 className="text-xs font-bold text-blue-600 mb-2 flex items-center gap-1"><Icons.PenTool size={14}/> æ­£åœ¨ç»˜åˆ¶åŒºåŸŸ...</h3>
                                        <p className="text-[10px] text-blue-500 mb-2">åœ¨åœ°å›¾ä¸Šç‚¹å‡»æ·»åŠ é¡¶ç‚¹ï¼Œè‡³å°‘3ä¸ªç‚¹</p>
                                        <div className="flex gap-2">
                                            <button onClick={finishDrawing} className="flex-1 bg-blue-600 text-white py-1 rounded text-xs hover:bg-blue-700">å®Œæˆç»˜åˆ¶</button>
                                            <button onClick={() => { setDrawingPoints([]); setActiveTool(null); }} className="flex-1 bg-white text-slate-600 border py-1 rounded text-xs hover:bg-slate-50">å–æ¶ˆ</button>
                                        </div>
                                    </div>
                                ) : (
                                    <button onClick={() => setActiveTool('draw-region')} className="w-full flex items-center justify-center gap-2 bg-white border-2 border-dashed border-slate-300 text-slate-500 py-2 rounded-lg hover:border-blue-400 hover:text-blue-500 hover:bg-blue-50 transition-all text-xs font-bold">
                                        <Icons.Square size={14}/> ç»˜åˆ¶è°ƒç ”åŒºåŸŸ (åœˆåœ°)
                                    </button>
                                )}

                                <div>
                                    <h3 className="text-xs font-bold text-slate-400 uppercase mb-2">æ·»åŠ æ ‡è®°</h3>
                                    <div className="space-y-2">
                                        <button onClick={() => setActiveTool('obstacle')} className={`w-full flex gap-3 p-3 border rounded-lg transition-colors ${activeTool==='obstacle'?'bg-red-50 border-red-500 ring-2 ring-red-200':''}`}><div className="text-red-600 bg-red-100 p-2 rounded-full"><Icons.AlertTriangle/></div><div className="text-left"><div className="font-bold text-sm">éšœç¢ç‚¹</div><div className="text-xs text-slate-500">æ ‡è®°å°é˜¶/é™¡å¡</div></div></button>
                                        <button onClick={() => setActiveTool('facility')} className={`w-full flex gap-3 p-3 border rounded-lg transition-colors ${activeTool==='facility'?'bg-green-50 border-green-500 ring-2 ring-green-200':''}`}><div className="text-green-600 bg-green-100 p-2 rounded-full"><Icons.CheckCircle/></div><div className="text-left"><div className="font-bold text-sm">è®¾æ–½ç‚¹</div><div className="text-xs text-slate-500">æ ‡è®°ç”µæ¢¯/å¡é“</div></div></button>
                                        <button onClick={() => setActiveTool('experience')} className={`w-full flex gap-3 p-3 border rounded-lg transition-colors ${activeTool==='experience'?'bg-blue-50 border-blue-500 ring-2 ring-blue-200':''}`}><div className="text-blue-600 bg-blue-100 p-2 rounded-full"><Icons.Users/></div><div className="text-left"><div className="font-bold text-sm">ä½“éªŒç‚¹</div><div className="text-xs text-slate-500">é€šè¿‡æ„Ÿå—/å»ºè®®</div></div></button>
                                    </div>
                                </div>
                                
                                {/* [æ ¸å¿ƒæ–°å¢] åœ°å›¾è¦ç´ è§†å›¾ */}
                                <div>
                                    <h3 className="text-xs font-bold text-slate-400 uppercase mb-2 flex items-center gap-1"><Icons.Layers size={14}/> åœ°å›¾è¦ç´ è§†å›¾</h3>
                                    <p className="text-[10px] text-slate-500 mb-2">åˆ‡æ¢åº•å›¾çªå‡ºæ˜¾ç¤ºç‰¹å®šåœ°ç†è¦ç´ </p>
                                    <div className="grid grid-cols-2 gap-2">
                                        {Object.keys(MAP_ELEMENTS).map(key => {
                                            const element = MAP_ELEMENTS[key];
                                            const isSelected = activeElementFilters === key;
                                            return (
                                                <button 
                                                    key={key} 
                                                    onClick={() => toggleElementFilter(key)}
                                                    className={`flex items-center gap-2 p-2 rounded-lg text-xs transition-colors border ${isSelected ? 'bg-blue-100 border-blue-400 text-blue-700 font-bold' : 'bg-white text-slate-600 hover:bg-slate-50'}`}
                                                >
                                                    <element.icon size={16}/>
                                                    {element.name}
                                                </button>
                                            )
                                        })}
                                    </div>
                                </div>
                                
                                <div>
                                    <h3 className="text-xs font-bold text-slate-400 uppercase mb-2 flex items-center gap-1"><Icons.Layers size={14}/> æ ‡è®°ç‚¹å›¾å±‚</h3>
                                    <div className="flex bg-slate-100 p-1 rounded-lg mb-3">
                                        {Object.keys(TILE_LAYERS).map(key => (
                                            <button key={key} onClick={() => setActiveBaseLayer(key)} className={`flex-1 py-1 text-xs rounded-md transition-all ${activeBaseLayer === key ? 'bg-white shadow text-blue-600 font-bold' : 'text-slate-500 hover:text-slate-700'}`}>{TILE_LAYERS[key].name}</button>
                                        ))}
                                    </div>
                                    <div className="space-y-2">
                                        {[{ id: 'obstacle', label: 'éšœç¢ç‚¹', color: 'text-red-500' }, { id: 'facility', label: 'è®¾æ–½ç‚¹', color: 'text-green-500' }, { id: 'experience', label: 'ä½“éªŒç‚¹', color: 'text-blue-500' }].map(item => (
                                            <div key={item.id} className="flex items-center justify-between p-2 border rounded hover:bg-slate-50 cursor-pointer" onClick={() => toggleLayer(item.id)}>
                                                <div className="flex items-center gap-2"><span className={`w-2 h-2 rounded-full ${item.id === 'obstacle' ? 'bg-red-500' : item.id === 'facility' ? 'bg-green-500' : 'bg-blue-500'}`}></span><span className="text-sm text-slate-700">{item.label}</span></div>
                                                {visibleTypes[item.id] ? <Icons.Eye size={16} className="text-slate-400"/> : <Icons.EyeOff size={16} className="text-slate-300"/>}
                                            </div>
                                        ))}
                                    </div>
                                </div>
                            </div>
                            <div className="p-4 border-t flex gap-2 bg-slate-50">
                                <button onClick={()=>setShowStats(true)} className="flex-1 flex-col flex items-center justify-center gap-1 bg-slate-100 py-2 rounded text-[10px] hover:bg-slate-200"><Icons.BarChart2 size={16}/>ç»Ÿè®¡</button>
                                <button onClick={exportData} className="flex-1 flex-col flex items-center justify-center gap-1 bg-slate-100 py-2 rounded text-[10px] hover:bg-slate-200"><Icons.Download size={16}/>æ•°æ®</button>
                                <button onClick={handleSaveSnapshot} className="flex-1 flex-col flex items-center justify-center gap-1 bg-slate-800 text-white py-2 rounded text-[10px] hover:bg-slate-700"><Icons.Camera size={16}/>å­˜å›¾</button>
                            </div>
                        </div>
                        <div className="absolute top-4 left-4 pointer-events-auto md:hidden">
                            <button onClick={() => setShowSidebar(!showSidebar)} className="bg-white p-2 rounded shadow hover:bg-gray-100 text-slate-600">èœå•</button>
                        </div>
                        {renderDetailForm()}
                        {renderStatsModal()}
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>